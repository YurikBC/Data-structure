<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Project</title>
</head>
<body>
  <script>

  //// Числа Фибоначчи. Задача: написать функцию, которая возвращает сумму двух предыдущих в числах Фибоначчи

    function fiban(n){
      var fib = [0,1]                                   //добавляю базовый шаблон для массива
      for (var i = 0; i < Infinity; i++){               //прокручиваю цикл до бесконечности
          i = fib[fib.length-1] + fib[fib.length-2]     //по формуле Fn = Fn-1 + Fn-2 устанавливаю критерии прокрутки цикла
            fib.push(i)
          if(fib[n-1] + fib[n-2]) break                 //цикл останавливается, когда только выполнение условий нашей задачи = true
      }
      var y = fib[n-1] + fib[n-2]                       //вычисляю сумму предыдущих чисел n из нашего  массива с числами Фиббоначи
      return console.log(y)
    }
    fiban(2);                                           //Пишем любое число и смотрим в консоль
                                                        // Как итог, все работает без ущерба быстродействия, как это было бы, если решать через рекурсию


//-----------------------------------------------------------------------------------------------------------------------------------------------------


  //Графы. Задача: найти и отобразить путь от точки а в точку б

  function path(list, start, end){                       //вызываем функцию call с 3-мя аргументами: 1) списком смежности (или матрицей смежности), начальной вершиной, конечной вершиной)
    var mass = [];                                       //создаем пустой массив, в который будем добавлять информацию о досягаемости каждой из вершин.
    var queue = [];                                     //создаем массив очереди, чтобы знать, вложенный массив какой вершины нам перебирать следующей. К примеру, если у вершины 3 вложенный массив [1,3], то имеено они и попадут в массив очереди.
    for (var i = 0; i < list.length; i++){
      mass[i] =  {                                      //создаем объект для каждой вершины со значениями дистанции, чтобы видеть, насколько конечная точка удалена от начальной, а также значение посещаемости
        visited: "no",                                  //по умолчанию, все вершины еще не посещены, и не имеют никакой дистанции
        distance: null
      }
    }
    mass[start].visited = 'yes'                           //а вот стартовой вершине, с которой и будет вычисляться путь, присваеваем посещаемость как "да" и присваиваем начальную дистанцию 0
    mass[start].distance = 0
    queue.push(start)                                    //сразу же добавляем стартовую вершину в нашу очередь

    for (var p = 0; p < list.length; p++){               //прокручиваем цикл в зависимости от длинны списка смежностей и останавливаем его только тогда, когда дистанция нашей конечной вершины будет равна чему-нибудь, кроме null
      var u = queue.shift()                              //убираем из очереди самое первое значение и возвращаем его через u. При первой прокрутке u = start
        for(var z = 0; z < list[u].length; z++){          //суть в том, что мы прокручиваем вложенный массив каждой вершины. К примеру, если вершина 3 содержит массив [1,5], это значит, что вершина 3 имееть путь к вершинам 1 и 5. Вершины 1 и 5 имеют свои вложенные пути. СОбственно так мы и находим конечную вершину.
          var temp = list[u][z]                            //к примеру, если бы у нас в очереди была вершина с массивом [1,5], то temp в данном случае после 2-ух прокруток был сначала 1, а потом 5. Соотвественно, так они добавляются в массив очереди.
            if(mass[temp].visited == 'no'){                   // меняем инидикатор посещаемости у вершин, с которыми нам удалось связаться
            mass[temp].visited = 'yes'
         }
            if(mass[temp].distance == null ){                     //то же самое делаем и с дистанцией, увеличивая еще каждый раз на 1. Дистанция исчисляется от нашей стартовой вершины
            mass[temp].distance = mass[u].distance + 1
         }
            queue.push(list[u][z])                              //добавляем ту вершину, которую будем прокручивать следующей. К примеру, если мы добавляем в массив 2 (и значений в массиве больше нет), то следующими будут прокручиваться, соотвественно 3, 4, 5 (по тем значениям, указанных в списке смежностей)
      }
        if(mass[end].distance !== null){                  //прерываем массив, если конечная вершина найдена
        break
      }
  }
      if(mass[end].distance == null){                     //если к конечной вершине пути нет, как к примеру, вершине 7, то сообщаем об этом
      console.log( end + ' cannot be visited')
    }
    console.log(mass)
}

var list = [                    //список смежностей, представляющий из себя многомерный массив. Индекс каждого вложенного массива - это вершина.
    [1],                        //вершина 0, которая имеет связь только с вершиной 1
    [0, 2, 5],                  // вершина 1, которая имеет связь с вершинами 2, 5 и 0
    [3, 4, 5],                  //вершина 2, которая имеет связь с вершинами 3, 4, и 5 и т.д
    [2, 6],
    [1, 2],
    [1, 2, 6],
    [3, 5],
    []                         //вершина 7, которая вообще ни с кем не связывается
    ];

//Вот как это все это выглядит, если изобразить схематично: https://ibb.co/jkwY6a

path(list, 0, 3);


//-----------------------------------------------------------------------------------------------------------------------------------------------------


  </script>
</body>
</html>
